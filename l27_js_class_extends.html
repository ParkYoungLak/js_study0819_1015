<html lang="en" dir="ltr">

<head>
    <meta charset="utf-8">
    <title>css extends </title>

</head>
<body>
  <h1>class 상속으로 재사용을 배우자.</h1>
  <ul>
    <li>상속은 부모의 타입(멤버)을 물려받는 것.</li>
    <li>상속 받았을 떄 부모가 생성자를 작성한 경우 꼭 부모의 생성자를호출해야한다 (super())</li>
    <li>멤버의 이름은 중복될 수 없다.</li>
    <li>get 멤버() 선언하면 멤버가 속성이 추가된다.(멤버로 한번 더 선언하면 안된다.)</li>
    <li>class A{name;get name(){};} X, class A{get name(){};} O</li>
    <li>javascript에서 getter setter를 선언한 멤버는 private로 선언해야함.</li>
    <li>부모의 함수를 재정의하려면 함수에서 부모의 함수를 다시 호출해야 한다.</li>
  </ul>
  <script>
class Animal{
  name;bark;age;species;
  constructor(name, bark, age, species){
    this.name=name;
    this.bark=bark;
    this.age=age;
    this.species=species;
  }
  callName(){
    alert(this.name);
  }
  }
  //Dog는 Animal의 특성을 모두 가짐.
  //Dog 는 털{길이:,색:,곱슬한정도:}과 주인[경민,은송] 후각(100m) 
  class Dog extends Animal{
    hair; owner; smell;
    constructor(name, bark, age, species,hair, owner, smell){
      super(name,bark,age,species);
      this.hair=hair;
      this.owner=owner;
      this.smell=smell;
    }
  }
  class Maltese extends Dog{
    //전역변수 이름과 get멤버의 이름을 동일하게 작성하지 않기(get 멤버()가 무시당함.)
    //동일하게 작성하고 싶으면 꼭 private로 선언하세요.
    barking; smeling;
    constructor(name,age,owner){
      super(name,"말티즈멍멍",age,"마르티즈",{ length: Infinity, color: "white", curly: "middle"},owner,500)
      this.barking = "often" + this.bark;
    }
    get barking() {
      return this.barking;
    }
    callName(){
      dog.callName(); //부모속성이 맘에 들면 super로 받아오기.
      alert(this.species)
    }
  }
  
  const dog = new Animal("hongu","멍멍멍멍",10,"마르티즈");
  console.log(dog)
  const animal_dog= new Dog("hongu","멍멍멍멍",10,"마르티즈",{length:20,color:"white",curly:"middle"},"경민",500);
  console.log(animal_dog);
  const maltiz_dog = new Maltese();
  console.log(maltiz_dog);
  console.log(maltiz_dog.callName())
  </script>
</body>
</html>