<!DOCTYPE html>
<html lang="en" dir="ltr">
  <head>
    <meta charset="utf-8">
    <title>js array method2</title>
  </head>
  <body>
<main>
  <h1>자바스크립트의 배열 메소드(loop iteration 속성이 있는 메소드.)</h1>
  <p>배열의 메소드 중에 가장 유용한 3가지는 모두 반복문의 속성을 가진다.</p>
  <p>반복문 속성이 있는 배열의 메소드는 배열의 길이만큼 실행되고 실행될 때 익명함수를 재정의할 수 있는데
    이 함수를 콜백함수라고 한다. 
  </p>
  <p>Array.filter(callback function) : 콜백함수는 배열의 길이만큼 실행된다.</p>

  <article class="">
    <h2>forㄷEach(function(value, index, self){}) : forEach 는 배열의 길이만큼 반복 실행된다.</h2>
    <p>forEach는 break 로 콜백함수 호출을 막을 수 없다.</p>
    <p>forEach는 return 을 작성해도 콜백함수는 호출된다.</p>
    <p>for(v of array){if(condition){break;}, forEach(()=>{break;} (X))</p>
    <p>function(){for(v of array){if(v==09)return false;} : return은 함수를 종료하기
      때문에 반복문도 종료된다.
    </p>
    <p>forEach(function(v){return false;}) 
      :콜백함수는 return으로 종료되어도 배열의 길이만큼 나서 호출된다.</p>
    <ul>
      <li>["바나나킥","썬칩","빼빼로","오감자"].forEach(function(v,i){})
<script>
  const a = ["바나나킥","썬칩","빼뺴로","오감자"];
  a.forEach((v,i,s)=>{
    console.log(`v : ${v}/ i : ${i}, s: ${s}`);
  })

  for(let i=0 ; i <a.length ; i++){
    console.log(`a[i] : ${a[i]}`);
  }
</script>
      </li>
      <li>Array.forEach(function(value,index,self){})</li>
      <li>Array.forEach(function(value,index){})</li>
      <li>Array.forEach((value)=>{})</li>
      <li>Array.forEach((value,index)=>{})</li>
      <li>
<script>
  const nums = [21,110,-100,30,0,13];
  let min = Infinity;
  for(let i=0;i<nums.length;i++){
    if(min>nums[i]){
      min = nums[i];
    }
  }console.log(min)
//최소값
  let minNum = Infinity;
  let maxNum =-Infinity;
  nums.forEach((v) => {
    if(minNum>v)minNum = v;
    if(maxNum<v)maxNum = v;
    });
    document.write(`minNum : ${minNum} / maxNum : ${maxNum}`);
console.log("dd" instanceof Object);

//sum of nums
let sum =0;
nums.forEach((val)=>{
  sum+= val;
})
document.write(`sum : ${sum}`);

const num2 = [21,"십", 110, -100, 30, 0, "10", 13];
//문자 삭제.
num2.forEach((val,i)=>{
  //console.log(` val typeof : ${Boolean(typeof 'string')}`);
  if(typeof val == 'string'){
    console.log(`val: ${val} / i : ${i}`)
    num2.splice(i,1);
  }
  console.log(num2) 
})
const num3 =[21,110,-110,30,0,13];
//절대값의 제곱인 값인 새 배열
num3.forEach((v,i,self)=>{
  self[i] = v * v;
  console.log(num3)
});
</script>

      </li>
    </ul>
  </article>
<article>
  <h2>map()배열의 값을 수정하는 함수</h2>
  
  <p>Array.map(value, index, self)=>{return changeValue} : return 작성하면 해당 인덱스의  value가 바뀐 새로운 배열을 반환.</p>
  <p>Array.map(Math)== newArray : Math의 함수로 모든 인덱스의 값이 바뀐 새로운 배열을 반환.</p>
</article>
<script>
  const num3Result = num3.map(v=>
    //console.log(`v: ${v} i: ${i} c:${s}`);
    v/100 
  );
  console.log(num3Result);
  
  console.log(num3) 
  let num4 = num3.map(v => v*v);
  console.log(num4);
  let num5 = num3.map(v=> Math.pow(Math.sqrt(v),3))
  console.log(num5);
</script>
<article>
  <h2>filter() 조건에 통과한 배열 요소만 새로운 배열로 만든다.</h2>
  <p>Array.filter(function(v,i,s){return boolean})</p>
  <ul>
    <li> [-200,100,-189,40,-50,0,-10,20,1].filter(v=> v>-11);
      <script> 
        
        const num6 = [-200,100,-189,40,-50,0,-10,20,1];
        const test = function(v){return v>-11};
        console.log(`v>-11 : ${num6.filter(test)}`);
        console.log(num6.filter((v)=> v> -10))
        //함수에 매개변수로 익명함수를 사용하는 이유는 가독성을 높이기 위해서.
        const num7 = [-200,"백",100,-189,40,"40",-50,-10,"십",1]
        console.log(`문자제외 : ${num7.filter(v=> typeof v =='number')}`);
      </script>
    <li>[{name:"k",age:!0},{name:"a",age:20},{name:"b",age:30},{name:"c",age:40}]
      <script>
        const persons=[{name:"k",age:10},{name:"a",age:20},{name:"b",age:30},{name:"c",age:40}];
        let over20_presons = persons.filter((v,i)=>{
          //console.log(`v.age : ${v.age} / i : ${i}`);
          return v.age > 20;
        })
        document.write(`over_20 : ${JSON.stringify(over20_presons)}`);
      </script>
    </li>
  </ul>
</article>
<article>
  
  <h2>every() : 배열의 모든 요소를 반복적으로 검사하는 함수(callback 함수) 의 return값이 모두 true이면 true 반환.</h2>
  <p>Array.every(function(v,i,s){ return boolean})=> boolean </p>
  <p>하나라도 false가 있는 every실행구문은 콜백함수 호출을 멈추고 false를 반환.</p>
  <p>a[0]>10 && a[1]>10 && a[2]>10...검사.</p>
  <ul>
    <li>[-200,100,-189,40,-50,0,-10,20,1]의 값이 모두 200보다 작은지 검사.
      forEach로 검사는 할 수 있지만 break가 없고 return 작성이 용이하지 않아서 검사식에 적절하지 않다.
      <script>
        let testValue = 100;
        let testValueResult = true; //false가 나오면 반복중단 후 결과 반환.
        num6.forEach((v)=> {console.log(v < testValue)})
        console.log(num6);
        
        num6.forEach((v)=>{
          if(v>=testValue){
            testValueResult =false;
            //break 가 없어서 할 수 없다.
          }
        })
        console.log(testValueResult);
        document.write(`// testValueResult : ${testValueResult}`);
      </script>
    </li>
    <li> [-200,100,-189,40,-50,0,-10,20,1];
      <script>
        let result= num6.every(function(v,i,s){
          return v< 100;
        });
        document.write(`result : ${result}`);
      </script>
    </li>
  </ul>
</article>
<article>
  <h2>some() : 배열의 모든 요소를 반복적으로 검사하는 함수(callback 함수) 의 return값이 하나라도 true이면 true 반환.</h2>
  <p>Array.some(function(v,i,s){ return boolean})==> boolean </p>
  <p>하나라도 true가 있는 some 실행구문은 콜백함수 호출을 멈추고 true 를 반환.</p>
  <p>a[0]>10 || a[1]>10 || a[2]>10... or 검사.</p>
  <ul>
    <li>[-200,100,-189,40,-50,0,-10,20,1].some(v=> v 200이상인지) :
      <script>
       console.log(num6.some((v)=>v <= -200));
       document.write(num6.some((v)=>v <= -200))
      </script>
    </li>
    <li>num6 v가 - 200이하인지 forEach로 작성 :
      <script> 
        let result_01;
      num6.forEach((v)=>{
        result_01 = (v <= -200);
        console.log(result_01);
      }) 
      document.write(result_01) 
      </script>
    </li>
  </ul>
</article>
<article>
  <h2> reduce((result,currentValue)=>{return}, resultValue=0) </h2>
  <p>배열의 모든 요소를 하나의 값으로 줄인다.(배열의 길이만큼 함수를 호출하고(callback function) 하나가 된 값을 반환한다.)</p>
  <ul>
    <li>[10,20,30,40,50].reduce((x,y)=>{return x+y}) <script>document.write([10, 20, 30, 40, 50].reduce((x, y) => { return x + y }))</script></li>
    <li>[10,20,30,40,50].reduce((x,y)=>x+y,100) <script>document.write([10, 20, 30, 40, 50].reduce((x, y) =>  x +y ,100 )) //100에서 시작</script></li> 
    <li>[10,20,30,40,50].reduce((x,y)=>(x+2)/2) <script>document.write([10, 20, 30, 40, 50].reduce((x, y) => (x + 2) / 2))</script></li>

  </ul>
    <script>
      const arr = [10,20,30,40,50];
      //arr.reduce((x,y)=>x+y,0) default 값은 지정가능.
      //0+a[0]=a0
      //a0+a[1]=a1
      //a1+a[2]=a2
      //a2+a[3]=a3
      //a3+a[4]=a4
      //x=a4
      console.log(arr.reduce(function(x,y){return x+y;}));            
      console.log(arr.reduce( (x, y) => x - y ));


      let sum_01= 0; //reduce x
      arr.forEach((item)=>{sum_01+=item});
      console.log(`sum : ${sum_01}`);

    </script>
  
</article>
<article>
  <h2> reduceRight(function(x,y){return},xValue=0) </h2>
  <p>배열의 마지막에서부터 모든 요소를 하나의 값으로 줄인다.(배열의 길이만큼 함수를 호출하고(callback function) 하나가 된 값을 반환한다.)</p>
  <ul>
    <li>[10,20,30,40,50].reduceRight((x,y)=>{return x+y})<script>document.write([10, 20, 30, 40, 50].reduceRight((x, y) => { return x + y }))</script></li>
    <li>[10,20,30,40,50].reduceRight((x,y)=>{return x-y})<script>document.write([10, 20, 30, 40, 50].reduceRight((x, y) => x - y))</script></li>
    <li>[10,20,30,40,50].reduceRight((x,y)=>(x+2)/2)<script>document.write([10, 20, 30, 40, 50].reduceRight((x, y) => (x + 2) / 2))</script></li>
  
  </ul>
</article>
<article>
  <h2>Array.find((v,i,s)=> boolean)</h2>
  <p>배열에서 테스트를 통과한 첫번째 요소를 값으로 반환.</p>
  <ul>
    <li>[1,2,3,4,5,6,7].find(v=>v==4) : <script>document.write([1, 2, 3, 4, 5, 6, 7].find(v => v == 4))</script></li>
    <li>[1,2,3,4,5,6,7].find(v=>v>4) : <script>document.write([1, 2, 3, 4, 5, 6, 7].find(v => v > 4))</script></li>
    <li>["a","b","c","D","E","F"].find(v=>v=="D") : <script>document.write(["a", "b", "c", "D", "E", "F"].find(v => v == "D"))</script></li>
    <li>["a","b","c","D","E","F"].find(v=>v=="d") : <script>document.write(["a", "b", "c", "D", "E", "F"].find(v => v == "d"))</script></li>
  </ul> 
</article>
<article>
  <h2>Array.findIndex((v,i,s)=> boolean)</h2>
  <p>배열에서 테스트를 통과한 첫번째 요소의 인덱스값을 반환(찾지 못하면 -1).</p>
  <ul>
    <li>[1,2,3,4,5,6,7].findIndex(v=>v==4) : <script>document.write([1, 2, 3, 4, 5, 6, 7].findIndex(v => v == 4))</script></li>
    <li>[1,2,3,4,5,6,7].findIndex(v=>v>4) : <script>document.write([1, 2, 3, 4, 5, 6, 7].findIndex(v => v > 4))</script></li>
    <li>["a","b","c","D","E","F"].findIndex(v=>v=="D") : <script>document.write(["a", "b", "c", "D", "E", "F"].findIndex(v => v == "D"))</script></li>
    <li>["a","b","c","D","E","F"].findIndex(v=>v=="d") : <script>document.write(["a", "b", "c", "D", "E", "F"].findIndex(v => v == "d"))</script></li>
  </ul> 
</article>
<article>
  <h2>includes()</h2>
  <p>배열에 해당 요소가 있는지 검사를 boolean(return boolean)</p>
  <ul>
    <li>["a","b","c","D","E","F"].includes("D") : <script> document.write(["a", "b", "c", "D", "E", "F"].includes("D"))</script></li>
    <li>["a","b","c","D","E","F"].includes("d") : <script> document.write(["a", "b", "c", "D", "E", "F"].includes("d"))</script></li>
  </ul>
</article>

<article>
  <h2>indexOf()</h2>
  <p>배열에 해당 요소가 있는지 검사해서 해당 위치를 (index)를 반환(첫번째 검색되는 항목.)</p>
  <ul>
    <li>["a","b","c","D","E","F"].indexOf("D") :
      <script> document.write(["a", "b", "c", "D", "E", "F"].indexOf("D"))</script>
    </li>
    <li>["a","b","c","D","E","F"].indexOf("d") :
      <script> document.write(["a", "b", "c", "D", "E", "F"].indexOf("d"))</script>
    </li>
  </ul>
</article>

<article>
  <h2>lastIndexOf()</h2>
  <p>배열에 해당 요소가 있는지 검사해서 해당 위치를 (index)를 반환(마지막에 검색되는 항목.)</p>
  <ul>
    <li>["a","b","c","D","E","F"].lastIndexOf("D") :
      <script> document.write(["a", "b", "c", "D", "E", "F"].lastIndexOf("D"))</script>
    </li>
    <li>["a","b","c","D","E","F"].lastIndexOf("d") :
      <script> document.write(["a", "b", "c", "D", "E", "F"].lastIndexOf("d"))</script>
    </li>
  </ul>
</article>
<article>
  <h2>keys()</h2>
  <p>keys 를 호출하면 반복과 관련된 객체인 itertor가 반환되고, iterator 에서 key[index]를 확인할 수 있다. </p>
  <p>Iterator.next() => [반환되는 데이터, 반환할 데이터가 있는] / for of에서 사용(반환되는 데이터 of Iterator.next())] </p>
  <p>[10,20,30,40].keys() : <script>document.write([10, 20, 30, 40].keys()) </script></p>
  <p>[10,20,30,40].keys() for of 로 출력 : 
    <script>
      const arr2 = [10, 20, 30, 40]
     const keys =arr2.keys(); 
     for(key of keys){
       document.write(` key : ${key}`);
     }
      </script></p>
      <p>Object.keys([10,20,30,40]) : <script>document.write(Object.keys([10,20,30,40])) </script> </p>
</article>

<article>
  <h2>Array.isArray()</h2>
  <p>typeof Array : object 를 반환한다. 이때 데이터가 배열인지 확인하는 함수</p>
  <p>배열은 기본데이터 타입이 아니기 때문에 리터럴한 입력을 사용해도 인스턴스 객체다. </p>
  <p>let a= 10;(리터럴) // let a= new Number(), const b=[1,2,3] // const b = new Array(1,2,3) </p>
  <ul>
    <li>[1,2,3,4] : <script>document.write(typeof [1,2,3,4])  </script></li>
    <li>[1,2,3,4] : <script>document.write(Array.isArray([1,2,3,4]))  </script></li>
    <li>Array.isArray(new Array(1,2,3)) : <script>document.write(Array.isArray(new Array(1, 2, 3)))  </script></li>

    <li>객체 instanceof 타입 : 객체의 타입을 비교, 이때 타입은 부모도 포함(기본데이터 타입은 비교할 수 없다.) </li>
    <li>[1,2,3] instanceof Array : <script>document.write([1,2,3]instanceof Array) </script></li> 
    <li>[1,2,3] instanceof Object : <script>document.write([1,2,3]instanceof Object) </script></li>
    <li>new Array(1,2,3) instanceof Array : <script>document.write(new Array(1, 2, 3) instanceof Array) </script></li>
    <li>"안녕" instanceof Object : <script>document.write("안녕" instanceof Object) </script></li>
    <li>"안녕" instanceof String : <script>document.write("안녕" instanceof String) </script></li>
    <li>new String("안녕") instanceof String : <script>document.write(new String("안녕") instanceof String) </script></li>
  </ul>
</article>

<article>
  <h2>문제</h2>
  <ul>
    
    <li>총합을 구하세요. <input type="button" value="총점" onclick="totalScore(this)"></li>
    <li>평균점수를 구하세요.<input type="button" value="평균" onclick="avgScore(this)"></li>
    <li>최소점수를 찾으세요.<input type="button" value="최소" onclick="minScore(this)"></li>
    <li>최대점수를 찾으세요.<input type="button" value="최대" onclick="maxScore(this)"></li>
    <li>낙제가 있는지 찾으세요.<input type="button" value="낙제" onclick="failScore(this)"></li>
    <li>만점이 있는지 찾으세요.<input type="button" value="만점" onclick="perfectScore(this)"></li>
    <li>모든 점수를 100점 만접에서 4.5 만점으로 변경하세요.
      <button type="button" name="button" onclick="turnToGrade(this)">4.5점 만점</button>
    </li>
  </ul>
  <form name="someTestForm" action="index.html" method="post">
    <p><label>수학점수 : <input type="number" class="score" name="m" value="70"></label></p>
    <p><label>영어점수 : <input type="number" class="score" name="e" value="90"></label></p>
    <p><label>화학점수 : <input type="number" class="score" name="c" value="100"></label></p>
    <p><label>국사점수 : <input type="number" class="score" name="h" value="30"></label></p>
    <p><label>국어점수 : <input type="number" class="score" name="k" value="70"></label></p>
    <p><label>수학점수 : <input type="number" class="score" name="m" value="70"></label></p>
    <p><label>총 점수 : <input type="number" class="score" name="total" value="0" readonly></label></p>
    <p><label>평균점수 : <input type="number" class="avg" name="avg" value="0" readonly></label></p>
    <p><label>최소점수 : <input type="number" class="min" name="min" value="0" readonly></label></p>
    <p><label>최대점수 : <input type="number" class="max" name="max" value="0" readonly></label></p>
    <p><label>낙제가(>50)있는지(0/1) <input type="number" name="is_f" value="0" readonly></label></p>
    <p><label>만점이 있는지(0/1)<input type="number" name="is_ten" value="0" readonly></label></p>
  </form>
</article>
<script>
  const someTestForm = document.forms["someTestForm"];
  const scors = someTestForm.querySelectorAll("[type=number].score");
  scors.forEach((item,i)=>{
    console.log(typeof item.value)
    console.log(item.value);
  })
  const scoreList=Array.from(scors); //domList를 array로 변경 => every,some, map 사용가능
  scoreList.map(function(v){
    console.log(v);
  })

  
  let scors1=[70,90,100,30,70,70];
  let scors2=0;
  function totalScore(){
    scors1.forEach(function(el){
      scors2+=el;
      console.log(scors2);
    })
    console.log(typeof scors2);
    document.querySelector("[name=total]").innerText= scors2;
  }
  function avgScore(){
    
  }
  function minScore(){

  }
  function maxScore(){

  }
  function failScore(){

  }
  function perfectScore(){

  }
  function turnToGrade(){
    
  }
</script>
</main>
  </body>
</html>
